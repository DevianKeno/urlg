/*

Program Title: Data Generator
Date written: October 11, 2024
Date revised: December 17, 2024

Programmer/s:
    Gian Paolo Buenconsejo

Purpose:
    This component is responsible for generating, reading, writing, and processing data for the system.
    The data entries are composed of player stat and room pref feature sets filled with randomized values.
    All datasets generated by this component will not reflect on the final result of the experimentation
    and is only generated for the sole purpose of testing the functionality of the algorithms.
    
Control:
    1. GenerateDatasetEntries()
    2. CreateDataEntry()
        -> ConstructPlayerRandom()
        -> ConstructRoomRandom()
    3. WriteToCSV()

    This generates sample datasets with a specified amount of entries,
    firstly creating feature sets with randomized parameters, on which after
    it stores the entries into a list, then writes it into a .csv file at a target path.

Data Structures:
    
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using UnityEngine;
using TMPro;
using Newtonsoft.Json;
using SFB;

using RL.Telemetry;
using RL.UI;
using RL.Classifiers;

namespace RL.RD
{
    /// <summary>
    /// Data structure representing a data entry from a dataset for AR.
    /// </summary>
    public struct ARDataEntry
    {
        public int GroundTruth { get; set; }
        public int SeedPlayer { get; set; }
        public int SeedRoom { get; set; }
        public Dictionary<StatKey, int> Values { get; set; }
    }

    public class Datagen : MonoBehaviour
    {
        /// <summary>
        /// Set parameters for the next generation of test dataset.
        /// </summary>
        [Header("Parameters")]
        /// <summary>
        /// Amount of entries to generate in the dataset. 
        /// </summary>
        public int EntryCount = 32767;
        /// <summary>
        /// Amount of rooms (rows) per generated player preference feature set.
        /// </summary>
        public int RoomsPerPlayerPreference = 32;
        [Range(0, 100)] public float FluctuationChance = 33;
        public float AcceptanceThreshold = 0.2f;

        [Header("Feature Parameters")]
        public int MaxUseCount = 1000;
        public int MaxEnemyCount = 15;
        public int MaxObstacleCount = 6;

        float progress = 0f;

        [SerializeField] RDTelemetryUI playerTelemetry;
        [SerializeField] RDTelemetryUI roomTelemetry;
        [SerializeField] TextMeshProUGUI statusTmp;

        void FixedUpdate()
        {
            if (gameObject.activeInHierarchy)
            {
                statusTmp.text = $"Generating dataset... {progress * 100}%";
            }
        }

        [ContextMenu("Generate Dataset")]
        public void GenerateDataset()
        {
            StartCoroutine(GenerateDatasetEntries());
        }

        IEnumerator GenerateDatasetEntries()
        {
            statusTmp.text = $"Generating dataset... {progress}%";
            float startTime = Time.time;

            var entries = new List<ARDataEntry>();
            PlayerStatCollection playerStats = RDTelemetryUI.ConstructPlayerRandom(MaxUseCount);

            int roomsLeft = RoomsPerPlayerPreference;
            for (int i = EntryCount; i > 0; i--)
            {
                /// Refresh/get a new player preference
                if (roomsLeft <= 0)
                {
                    playerStats = RDTelemetryUI.ConstructPlayerRandom(MaxUseCount);
                    roomsLeft = RoomsPerPlayerPreference;
                }

                /// Generate accepted rooms for current player preference
                for (int acceptLeft = RoomsPerPlayerPreference / 2; acceptLeft > 0; acceptLeft--)
                {
                    var acceptedRoom = GenerateTargetRoom(playerStats, Status.Accepted);
                    entries.Add(CreateDataEntry(playerStats, acceptedRoom, Status.Accepted));
                    roomsLeft--;
                    i--;
                }

                /// Generate rejected rooms for current player preference
                for (int rejectLeft = RoomsPerPlayerPreference / 2; rejectLeft > 0; rejectLeft--)
                {
                    var rejectedRoom = GenerateTargetRoom(playerStats, Status.Rejected);
                    entries.Add(CreateDataEntry(playerStats, rejectedRoom, Status.Rejected));
                    roomsLeft--;
                    i--;
                }

                progress = i / RoomsPerPlayerPreference;
            }
            statusTmp.text= $"Done generation.";

            statusTmp.text= $"Writing to file...";
            WriteToCSV(entries);

            float elapsedTime = Time.time - startTime;
            statusTmp.text= $"Dataset generated in {elapsedTime:##} ms";

            yield return null;
        }

        ARDataEntry CreateDataEntry(PlayerStatCollection playerStats, RoomStatCollection roomStats, Status status)
        {
            var entry = new ARDataEntry
            {
                SeedPlayer = playerStats.Seed,
                SeedRoom = roomStats.Seed,
                Values = new()
            };

            foreach (var key in Telemetry.Telemetry.PlayerStatsKeys)
            {
                entry.Values[key] = playerStats.GetStat(key).Value;
            }

            foreach (var key in Telemetry.Telemetry.RoomStatsKeys)
            {
                entry.Values[key] = roomStats.GetStat(key).Value;
            }

            entry.GroundTruth = GetGroundTruth(status);
            return entry;
        }

        int GetGroundTruth(Status status)
        {
            if (status == Status.Accepted)
            {
                if (UnityEngine.Random.Range(0, 101) <= FluctuationChance)
                    return 0;
                else
                    return 1;
            }
            else if (status == Status.Rejected)
            {
                if (UnityEngine.Random.Range(0, 101) <= FluctuationChance)
                    return 1;
                else
                    return 0;
            }
            else
            {
                return 0;
            }
        }

        RoomStatCollection GenerateTargetRoom(PlayerStatCollection playerStats, Status targetStatus)
        {
            for (int i = 0; i < AcceptRejectRD.MaxBulkGenerationTimes; i++)
            {
                var roomStats = RDTelemetryUI.ConstructRoomRandom(MaxEnemyCount, MaxObstacleCount);

                ARResult result = ARClassifier.Classify(playerStats, roomStats, AcceptanceThreshold, normalized: true);

                if (result.Status == targetStatus)
                {
                    return roomStats;
                }
            }

            return new(Telemetry.Telemetry.RoomStatsKeys);
        }

        public void WriteToCSV(List<ARDataEntry> entries)
        {
            string directory = Path.Combine(Application.persistentDataPath, "dataset");
            if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);
            string filepath = Path.Combine(directory, $"dataset-{DateTime.Now:yyyyMMdd_HHmmss}.csv");

            using (StreamWriter writer = new StreamWriter(filepath))
            {
                var playerStatKeys = Telemetry.Telemetry.PlayerStatsKeys.Select(key => key.ToString()).ToArray();
                var roomStatKeys = Telemetry.Telemetry.RoomStatsKeys.Select(key => key.ToString()).ToArray();
                var headers = new[] { "SeedPlayer", "SeedRoom" }
                    .Concat(playerStatKeys)
                    .Concat(roomStatKeys)
                    .Append("GroundTruth")
                    .Append("Classification");

                writer.WriteLine(string.Join(",", headers));

                foreach (var entry in entries)
                {
                    var row = new List<string>
                    {
                        entry.SeedPlayer.ToString(),
                        entry.SeedRoom.ToString()
                    };

                    foreach (var key in playerStatKeys)
                    {
                        row.Add(entry.Values.ContainsKey((StatKey) Enum.Parse(typeof(StatKey), key))
                            ? entry.Values[(StatKey) Enum.Parse(typeof(StatKey), key)].ToString()
                            : "0");
                    }

                    foreach (var key in roomStatKeys)
                    {
                        row.Add(entry.Values.ContainsKey((StatKey) Enum.Parse(typeof(StatKey), key))
                            ? entry.Values[(StatKey) Enum.Parse(typeof(StatKey), key)].ToString()
                            : "0");
                    }
                    
                    row.Add(entry.GroundTruth.ToString());

                    writer.WriteLine(string.Join(",", row));
                }
            }

            Debug.Log($"Dataset generated at '{filepath}'");
        }

        /// <summary>
        /// Reads results from the source folder, then converts it to a dataset eligible for GNB processing.
        /// </summary>
        public void ConvertArResultsToGnbDataset()
        {
            ParseARResults();
            WriteResultsToCSV();
        }

        List<ResultsJsonData> jsonDatas;
        /// <summary>
        /// Reads results from the source folder.
        /// </summary>
        public void ParseARResults()
        {
            jsonDatas = new();
            var directory = Path.Combine(Application.persistentDataPath, "results", "ar");
            if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);
            
            var filePaths = Directory.EnumerateFiles(directory)
                                .Where(file => file.EndsWith(".json") || file.EndsWith(".dat"));
            foreach (var filePath in filePaths)
            {
                try
                {
                    var content = File.ReadAllText(filePath);
                    var result = JsonConvert.DeserializeObject<ResultsJsonData>(content);
                    jsonDatas.Add(result);
                }
                catch
                {
                    continue;
                }
            }
        }

        /// <summary>
        /// Writes the results to a structured CSV format.
        /// </summary>
        public void WriteResultsToCSV()
        {
            if (jsonDatas == null || jsonDatas.Count <= 0) return;

            string directory = Path.Combine(Application.persistentDataPath, "dataset");
            if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);

            int index = 0;
            foreach (ResultsJsonData data in jsonDatas)
            {
                string filepath = Path.Combine(directory, $"gnb_result_data_{index}-{DateTime.Now:yyyyMMdd_HHmmss}.csv");
                
                using StreamWriter writer = new(filepath);
                
                var playerStatKeys = Telemetry.Telemetry.PlayerStatsKeys.Select(key => key.ToString()).ToArray();
                var roomStatKeys = Telemetry.Telemetry.RoomStatsKeys.Select(key => key.ToString()).ToArray();
                var headers = new[] { "SeedPlayer", "SeedRoom" }
                    .Concat(playerStatKeys)
                    .Concat(roomStatKeys)
                    .Append("DeathCount")    
                    .Append("GroundTruth")    
                    .Append("Classification");

                writer.WriteLine(string.Join(",", headers));

                foreach (DataEntry entry in data.Entries)
                {
                    var row = new List<string>
                    {
                        "-",    /// seed unwritten
                        "-"     /// seed unwritten
                    };

                    foreach (var statSave in entry.PlayerStats)
                    {
                        row.Add(statSave.Value.ToString());
                    }

                    foreach (var statSave in entry.RoomStats)
                    {
                        row.Add(statSave.Value.ToString());
                    }

                    row.Add(entry.DeathCount.ToString());
                    row.Add(entry.GroundTruth.ToString());
                    row.Add("1");

                    writer.WriteLine(string.Join(",", row));
                }

                index++;
                Debug.Log($"Wrote results into excel file at '{filepath}'");
            }
            
            Debug.Log($"Finished converting AR results excel file");
        }

        public void SelectDataset()
        {
            string datasetsDirectory = Path.Combine(Application.persistentDataPath, "dataset");
            string[] paths = StandaloneFileBrowser.OpenFilePanel("Select dataset (.csv)", datasetsDirectory, "csv", false);

            if (paths.Length > 0 && !string.IsNullOrEmpty(paths[0]))
            {
                List<string[]> content = CSVHelper.ReadCSV(paths[0]);
                ParseDatasetContent(content);
            }
        }

        void ParseDatasetContent(List<string[]> content)
        {
            var data = new GNBData();
            string[] headers = content[0];
            
            for (int i = 1; i < content.Count; i++)
            {
                string[] row = content[i];
                var entry = new ARDataEntry
                {
                    SeedPlayer = int.Parse(row[0]),
                    SeedRoom = int.Parse(row[1]),
                    Values = new Dictionary<StatKey, int>()
                };

                for (int j = 2; j < row.Length; j++)
                    if (Enum.TryParse(headers[j], out StatKey statKey))
                        entry.Values[statKey] = int.Parse(row[j]);

                if (int.Parse(row[^1]) == 1)
                    data.AcceptedEntries.Add(entry);
                else
                    data.RejectedEntries.Add(entry);
            }
        }
    }
}
